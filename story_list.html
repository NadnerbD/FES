<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<link rel="stylesheet" type="text/css" href="comments.css" />
	<script type="text/javascript">
		// fetch emoticon list
		function fetchEmotes(callback) {
			var request = new XMLHttpRequest();
			request.onload = function() {
				if(request.status == 200) {
					var emoteObject = {};
					var emoteList = JSON.parse(request.response);
					for(var item of emoteList) {
						emoteObject[item[0]] = "emotes/" + item[0] + ".png";
					}
					parser.registerEmotes(emoteObject);
					callback();
				}
			};
			request.overrideMimeType("application/json");
			request.open("GET", "emotes/emoticons.json", true);
			request.send(null);
		}
	</script>
	<script type="text/javascript">
		// fetch character list
		function fetchChars(callback) {
			var request = new XMLHttpRequest();
			request.onload = function() {
				if(request.status == 200) {
					var charList = JSON.parse(request.response);
					for(var item of charList) {
						charTable[item[0]] = "characters/" + item[1].split("/").pop();
					}
					callback();
				}
			};
			request.overrideMimeType("application/json");
			request.open("GET", "characters/characters.json", true);
			request.send(null);
		}
	</script>
	<script type="text/javascript" src="idb-wrapper.js"></script>
	<script type="text/javascript" src="bbcode.js"></script>
	<link rel="stylesheet" type="text/css" href="bbcode.css" />
	<style type="text/css">
		/* FontAwesome related styles */
		@font-face {
			/* Font Awesome by Dave Gandy - http://fontawesome.io */
			font-family: "FontAwesome";
			src: url("/fontawesome-webfont.ttf");
		}
		.fa {
			font-family: "FontAwesome";
			font-weight: normal;
			text-align: center;
		}
		.close_button {
			float: right;
			text-decoration: none;
			color: black;
		}
		.close_button:before {
			content: "";
		}
		.close_button:hover:before {
			content: "";
		}
		.thumbs_up:before {
			content: ""
		}
		.thumbs_down:before {
			content: ""
		}
		/* Table Styles */
		table {
			width: 100%;
			font-size: 12px;
			font-weight: bold;
			border-collapse: collapse;
			border: solid darkgray 1px;
		}
		thead td {
			background-color: lightgray;
			border: solid darkgray 1px;
		}
		td {
			padding: 2px;
			margin: 0px;
			border-right: solid darkgray 1px;
		}
		td.sortable {
			cursor: pointer;
		}
		tr:nth-child(2n) {
			background-color: lightgray;
		}
		tr.selected {
			background-color: #BBF;
		}
		tr.selected:nth-child(2n) {
			background-color: #AAF;
		}
		tbody td:nth-child(3) {
			text-align: right;
		}
		tbody td:nth-child(4) {
			text-align: right;
		}
		tbody td {
			min-width: 25px;
			max-width: 250px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		tbody td:nth-child(11) {
			text-align: right;
		}
		/* Tag Styles */
		img.character {
			cursor: pointer;
			margin-right: 2px;
			border-radius: 3px;
			height: 16px;
			vertical-align: -3px;
		}
		a.sort_indicator {
			float:right;
		}
		a.category {
			cursor: pointer;
			display: inline-block;
			font-size: 0.7em;
			padding: 2px 2px;
			margin-right: 2px;
			vertical-align: middle;
			color: white;
			background-color: darkgray;
			border: solid 1px rgba(0, 0, 0, 0.2);
			box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.4) inset;
			text-shadow: -1px -1px rgba(0, 0, 0, 0.2);
		}
		a.romance { background-image: linear-gradient(to bottom, #7C40BB 0%, #7139AA 100%); }
		a.tragedy { background-image: linear-gradient(to bottom, #EBA42D 0%, #D49528 100%); }
		a.sad { background-image: linear-gradient(to bottom, #E3628D 0%, #CE5980 100%); }
		a.dark { background-image: linear-gradient(to bottom, #9F2424 0%, #902121 100%); }
		a.comedy { background-image: linear-gradient(to bottom, #D4AE00 0%, #BF9D00 100%); }
		a.random { background-image: linear-gradient(to bottom, #4279D8 0%, #3B6EC3 100%); }
		a.crossover { background-image: linear-gradient(to bottom, #4AC1A8 0%, #43AE98 100%); }
		a.adventure { background-image: linear-gradient(to bottom, #48D354 0%, #41BE4C 100%); }
		a.slice_of_life { background-image: linear-gradient(to bottom, #424CD9 0%, #3B45C4 100%); }
		a.alternate_universe { background-image: linear-gradient(to bottom, #8E8E8E 0%, #818181 100%); }
		a.human { background-image: linear-gradient(to bottom, #BE895E 0%, #AB7C55 100%); }
		a.anthro { background-image: linear-gradient(to bottom, #BE6E5E 0%, #AB6355 100%); }
		/* Comment Overlay Styles */
		div.comments_overlay {
			position: fixed;
			top: 0px;
			left: 0px;
			bottom: 0px;
			right: 0px;
			background-color: rgba(0, 0, 0, 0.5);
			padding: 50px;
		}
		div.comments_overlay h2 {
			margin: 0px;
			padding: 20px;
			background-color: white;
			border: solid gray 1px;
		}
		div.story_comments {
			border-right: solid gray 1px;
			border-left: solid gray 1px;
			background-color: white;
			position: absolute;
			top: 72px;
			left: 0px;
			bottom: 0px;
			right: 0px;
			margin: 50px;
			overflow-y: scroll;
		}
		div.comment {
			border-right: none;
			border-left: none;
			border-top: none;
		}
	</style>
	<script type="text/javascript">
		var db;
		var charTable = {};
		//l2 = [{tag: "a", attrs: {title: cat, className: "category " + cat.toLowerCase().replace(/ /g, "_")}, children: [cat.slice(0, 2)]} for(cat of l)]
		var catTable = {
			"Romance": {tag: "a", attrs: {title: "Romance", className: "category romance"}, children: ["Ro"]}, 
			"Tragedy": {tag: "a", attrs: {title: "Tragedy", className: "category tragedy"}, children: ["Tr"]}, 
			"Sad": {tag: "a", attrs: {title: "Sad", className: "category sad"}, children: ["Sa"]}, 
			"Dark": {tag: "a", attrs: {title: "Dark", className: "category dark"}, children: ["Da"]}, 
			"Comedy": {tag: "a", attrs: {title: "Comedy", className: "category comedy"}, children: ["Co"]}, 
			"Random": {tag: "a", attrs: {title: "Random", className: "category random"}, children: ["Ra"]}, 
			"Crossover": {tag: "a", attrs: {title: "Crossover", className: "category crossover"}, children: ["Cr"]}, 
			"Adventure": {tag: "a", attrs: {title: "Adventure", className: "category adventure"}, children: ["Ad"]}, 
			"Slice of Life": {tag: "a", attrs: {title: "Slice of Life", className: "category slice_of_life"}, children: ["Sl"]}, 
			"Alternate Universe": {tag: "a", attrs: {title: "Alternate Universe", className: "category alternate_universe"}, children: ["Al"]}, 
			"Human": {tag: "a", attrs: {title: "Human", className: "category human"}, children: ["Hu"]}, 
			"Anthro": {tag: "a", attrs: {title: "Anthro", className: "category anthro"}, children: ["An"]}
		};
		var userAvatarURLs = {};
		var parser = new bbcode();
		function init() {
			db = new FFDB("fimcomments-db", function() {
				getUserAvatars(function() {
					fetchChars(function() {
						fetchEmotes(init2);
					});
				});
			});
		}
		function init2() {
			writeStoryTable();
			document.addEventListener("click", handleClick);
			document.addEventListener("mousedown", handleSelection);
			window.addEventListener("hashchange", showComments);
			showComments();
		}
		function getUserAvatars(callback) {
			db.getAll("users", function(items) {
				for(var i in items) {
					userAvatarURLs[items[i].name] = URL.createObjectURL(items[i].avatar);
				}
				callback();
			});
		}
		var lastSort, invertSort;
		var sortIndicator = createTree({tag: "a", attrs: {className: "sort_indicator"}, children: ["\u25B2"]});
		function moveSortIndicator(cat, element, type) {
			if(cat == lastSort) {
				invertSort = !invertSort;
			}else{
				invertSort = false;
			}
			lastSort = cat;
			sortIndicator.firstChild.data = invertSort?"\u25BC":"\u25B2";
			while(sortIndicator.childNodes.length > 1) sortIndicator.removeChild(sortIndicator.lastChild);
			if(type) sortIndicator.appendChild(type);
			element.appendChild(sortIndicator);
		}
		function handleClick(event) {
			if(event.target.classList.contains("sortable")) {
				var cat = event.target.getAttribute("data-sort");
				moveSortIndicator(cat, event.target);
				switch(cat) {
					case "title":
					case "author":
						sortByAlphabeticMember(cat, invertSort);
						break;
					case "wordcount":
					case "tracking":
					case "read_later":
					case "created":
					case "updated":
					// these last two are added at runtime
					case "floatRating":
					case "comment_count":
						sortByNumericMember(cat, invertSort);
						break;
					default:
						break;
				}
			}else if(event.target.classList.contains("category") || event.target.classList.contains("character")) {
				var type = event.target.classList.contains("category");
				var col = type?document.querySelector("td#categories"):document.querySelector("td#characters");
				var cat = event.target.title;
				moveSortIndicator(cat, col, event.target.cloneNode(true));
				sortByTag(type?"category":"character", cat, invertSort);
			}
		}
		var selectedRows = [];
		var lastSelected;
		function handleSelection(event) {
			if(event.target.parentNode.tagName == "TR") {
				// table row, perform selection routine
				var row = event.target.parentNode;
				// check that we're not clicking the header
				if(row.parentNode.tagName != "TBODY") return;
				// various behaviours for modifier keys
				if(event.shiftKey) {
					event.preventDefault();
					// make a range selection
					if(!lastSelected) {
						// if no selection has been made yet, we'll just set one
						selectedRows.push(row);
						row.classList.add("selected");
						lastSelected = row;
					}else{
						while(selectedRows.length) {
							selectedRows.pop().classList.remove("selected");
						}
						var trows = row.parentNode.children;
						var selecting = false;
						for(var ri = 0; ri < trows.length; ri++) {
							var trow = trows[ri];
							if(trow == lastSelected) selecting = !selecting;
							if(trow == row) selecting = !selecting;
							if(selecting || trow == lastSelected || trow == row) {
								trow.classList.add("selected");
								selectedRows.push(trow);
							}
						}
					}
				}else if(event.ctrlKey) {
					event.preventDefault();
					// toggle selection on element
					var index = selectedRows.indexOf(row);
					if(index == -1) {
						selectedRows.push(row);
						row.classList.add("selected");
					}else{
						selectedRows.splice(index, 1);
						row.classList.remove("selected");
					}
					lastSelected = row;
				}else{
					// set exclusive selection
					while(selectedRows.length) {
						selectedRows.pop().classList.remove("selected");
					}
					selectedRows.push(row);
					row.classList.add("selected");
					lastSelected = row;
				}
			}
		}
		function sortTable(table, func) {
			// sorts the contents of the first tbody according to a given sort function
			var c, tc = [];
			var tb = table.tBodies[0];
			// we remove the body before modifying it to prevent re-rendering the table while we are sorting it
			table.removeChild(tb);
			for(c of tb.children) {
				tc.push(c);
			}
			tc.sort(func);
			for(c of tc) {
				// we don't actually need to remove elements to append them
				// this just moves them to the end of the child list
				tb.appendChild(c);
			}
			table.appendChild(tb);
		}
		// document.querySelector("table").appendChild(document.createElement("tbody")); writeStoryTable();
		function sortByNumericMember(member, invert) {
			// sorts the table by a numeric base storyData member
			// works for booleans and dates as well as numbers
			// for RIL, Fav, created, and updated, we must deal with the case of an undefined value
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData[member];
				b = b.storyData[member];
				if(a == undefined) a = 0;
				if(b == undefined) b = 0;
				return a - b;
			}:function(b, a) {
				a = a.storyData[member];
				b = b.storyData[member];
				if(a == undefined) a = 0;
				if(b == undefined) b = 0;
				return a - b;
			});
		}
		function sortByAlphabeticMember(member, invert) {
			// sorts the table by a alphabetic base storyData member
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData[member].toLowerCase();
				b = b.storyData[member].toLowerCase();
				return a < b ? 1 : a > b ? -1 : 0;
			}:function(b, a) {
				a = a.storyData[member].toLowerCase();
				b = b.storyData[member].toLowerCase();
				return a < b ? 1 : a > b ? -1 : 0;
			});
		}
		function sortByTag(type, tag, invert) {
			// sorts the table by one of the character or category tags
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData.tags[type].indexOf(tag) != -1;
				b = b.storyData.tags[type].indexOf(tag) != -1;
				return a - b;
			}:function(b, a) {
				a = a.storyData.tags[type].indexOf(tag) != -1;
				b = b.storyData.tags[type].indexOf(tag) != -1;
				return a - b;
			});
		}
		function writeStoryTable() {
			// feed all the comments into a fragment so we can add them simultaneously
			var frag = document.createDocumentFragment();
			// get all comments ordered by location
			var groups, groupCount;
			db.getAll("stories", function(items) {
				var rows = document.createDocumentFragment();
				for(var story of items) {
					var cat;
					story.floatRating = story.ratings.up / (story.ratings.up + story.ratings.down); // so we can sort by this
					if(isNaN(story.floatRating)) story.floatRating = 0; // in case there are no ratings
					var percentRating = parseInt(story.floatRating * 100);
					var rowStruct = {tag: "tr", children: [
						{tag: "td", children: [{tag: "a", attrs: {href: "http://fimfiction.net/story/" + story.id}, children: [story.title]}]},
						{tag: "td", children: [{tag: "a", attrs: {href: "http://fimfiction.net/user/" + story.author.replace(/ /g, "+")}, children: [story.author]}]},
						{tag: "td", children: [story.wordcount.toLocaleString()]},
						{tag: "td", attrs: {
								style: percentRating == 0?"background-color: rgba(255, 0, 0, 0.3);":"background-image: linear-gradient(to right, rgba(0, 255, 0, 0.3) " + percentRating + "%, rgba(255, 0, 0, 0.3) " + percentRating + "%);"
							}, 
							children: [percentRating + "%"]
						},
						{tag: "td", children: [catTable[cat] for(cat of story.tags.category)]},
						{tag: "td", children: [{tag: "img", attrs: {src: charTable[cat], title: cat, className: "character"}} for(cat of story.tags.character)]},
						{tag: "td", children: story.created?story.created.toDateString().slice(4):""},
						{tag: "td", children: story.updated?story.updated.toDateString().slice(4):""},
						{tag: "td", attrs: {className: "fa"}, children: story.tracking?"":""},
						{tag: "td", attrs: {className: "fa"}, children: story.read_later?"":""},
						{tag: "td"} // this will contain the comment count
					]};
					var row = createTree(rowStruct);
					row.storyData = story;
					if("comment_count" in row.storyData) {
						if(row.storyData.comment_count > 0) {
							var link = document.createElement("a");
							link.appendChild(document.createTextNode(row.storyData.comment_count));
							row.lastChild.appendChild(link);
							link.href = "#story_comments/" + row.storyData.id;
						}else{
							row.lastChild.appendChild(document.createTextNode("0"));
						}
					}else{
						// the comment count hasn't been cached yet, so we must determine it
						row.storyData.comment_count = 0; // in case we try to sort by this immediately
						db.getKeysByIndex("comments", "location", "story/" + story.id, function (row) { return function(keys) {
							// cache the value so we don't have to do this again
							db.updateItems("stories", [{id: row.storyData.id, comment_count: keys.length}], function() {
								console.log(row.storyData.title + " has " + keys.length + " comments");
							});
							row.storyData.comment_count = keys.length;
							if(row.storyData.comment_count > 0) {
								var link = document.createElement("a");
								link.appendChild(document.createTextNode(row.storyData.comment_count));
								row.lastChild.appendChild(link);
								link.href = "#story_comments/" + row.storyData.id;
							}else{
								row.lastChild.appendChild(document.createTextNode("0"));
							}
						};}(row));
					}
					rows.appendChild(row);
				}
				document.querySelector("tbody").appendChild(rows);
			});
		}
		function showComments() {
			var h = window.location.hash.split("/");
			if(h[0] == "#story_comments") {
				var storyId = h[1];
				// blah, we have to get both the comments and the story name
				db.getItemsByIndex("comments", "location", "story/" + storyId, function(comments) {
					db.getItem("stories", storyId, function(story) {
						var header = {tag: "div", attrs: {className: "comments_overlay"}, children: [
							{tag: "h2", children: [
								((story && story.title) || storyId) + " (" + comments.length + ")",
								{tag: "a", attrs: {className: "fa close_button", href: "#"}}
							]},
							{tag: "div", attrs: {className: "story_comments"}}
						]};
						var container = createTree(header);
						for(var comment of comments) {
							container.lastChild.appendChild(createComment(comment, userAvatarURLs[comment.author]));
						}
						if(document.body.lastChild.className == "comments_overlay") {
							document.body.lastChild.remove();
						}
						document.body.appendChild(container);
					});
				});
			}else{
				// hide comments if no hash
				if(document.body.lastChild.className == "comments_overlay") {
					document.body.lastChild.remove();
				}
			}
		}
		function createComment(comment, avatar) {
			// JSONified HTML, because why not
			var cbody = parser.render(comment.data);
			// rewrite the quote links to point to fimfiction
			var qlinks = cbody.querySelectorAll("a.quote_link");
			for(var qlink of qlinks) {
				qlink.href = "http://fimfiction.net/" + comment.location + "/#comment/" + qlink.href.split("#")[1];
			}
			var structure = {tag: "div", attrs: {className: "comment"}, children: [
				{tag: "a", attrs: {className: "jump", name: comment.id}},
				{tag: "div", attrs: {className: "author"}, children: [
					{tag: "a", attrs: {className: "name", href: "http://fimfiction.net/user/" + comment.author.replace(/ /g, "+")}, children: [comment.author]},
					{tag: "img", attrs: {className: "avatar", src: avatar}}
				]},
				{tag: "div", attrs: {className: "data"}, children: [
					{tag: "div", attrs: {className: "comment_arrow"}, children: [
						{tag: "div"}
					]},
					{tag: "div", attrs: {className: "metadata"}, children: [
						{tag: "a", attrs: {href: "http://fimfiction.net/" + comment.location + "/#comment/" + comment.id}, children: ["#" + comment.id]},
						" · Chapter " + comment.chapter + " · " + comment.date.toLocaleString() + " · " + comment.ratings.up,
						{tag: "span", attrs: {className: "fa thumbs_up"}},
						" · " + comment.ratings.down,
						{tag: "span", attrs: {className: "fa thumbs_down"}}
					]},
					{node: cbody, attrs: {className: "body"}}
				]}
			]};
			return createTree(structure);
		}
		function createTree(node) {
			var tag;
			if(node.tag) {
				tag = document.createElement(node.tag);
			}else if(node.node) {
				// this method of adding existing nodes allows us to add extra attrs
				tag = node.node;
			}
			for(var attr in node.attrs) {
				tag[attr] = node.attrs[attr];
			}
			if(node.children) {
				for(var i = 0; i < node.children.length; i++) {
					if(typeof node.children[i] == "string") {
						tag.appendChild(document.createTextNode(node.children[i]));
					}else{
						tag.appendChild(createTree(node.children[i]));
					}
				}
			}
			return tag;
		}
	</script>
</head>
<body onload="init()">
	<table>
		<thead>
			<tr>
				<td class="sortable" data-sort="title">Title</td>
				<td class="sortable" data-sort="author">Author</td>
				<td class="sortable" data-sort="wordcount">Words</td>
				<td class="sortable" data-sort="floatRating">Ratings</td>
				<td id="categories">Categories</td>
				<td id="characters">Characters</td>
				<td class="sortable" data-sort="created">Created</td>
				<td class="sortable" data-sort="updated">Updated</td>
				<td class="fa sortable" data-sort="tracking"></td>
				<td class="fa sortable" data-sort="read_later"></td>
				<td class="fa sortable" data-sort="comment_count"></td>
			</tr>
		</thead>
		<tbody>
		</tbody>
	</table>
</body>
</html>

