<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<link rel="stylesheet" type="text/css" href="comments.css" />
	<script type="text/javascript">
		// fetch emoticon list
		function fetchEmotes(callback) {
			var request = new XMLHttpRequest();
			request.onload = function() {
				if(request.status == 200) {
					var emoteObject = {};
					var emoteList = JSON.parse(request.response);
					for(var item of emoteList) {
						emoteObject[item[0]] = "emotes/" + item[0] + ".png";
					}
					parser.registerEmotes(emoteObject);
					callback();
				}
			};
			request.overrideMimeType("application/json");
			request.open("GET", "emotes/emoticons.json", true);
			request.send(null);
		}
		// fetch character list
		function fetchChars(callback) {
			var request = new XMLHttpRequest();
			request.onload = function() {
				if(request.status == 200) {
					var charList = JSON.parse(request.response);
					for(var item of charList) {
						charTable[item[0]] = "characters/" + item[1].split("/").pop();
					}
					callback();
				}
			};
			request.overrideMimeType("application/json");
			request.open("GET", "characters/characters.json", true);
			request.send(null);
		}
	</script>
	<script type="text/javascript" src="idb-wrapper.js"></script>
	<script type="text/javascript" src="bbcode.js"></script>
	<link rel="stylesheet" type="text/css" href="bbcode.css" />
	<style type="text/css">
		/* FontAwesome related styles */
		@font-face {
			/* Font Awesome by Dave Gandy - http://fontawesome.io */
			font-family: "FontAwesome";
			src: url("/fontawesome-webfont.ttf");
		}
		.fa {
			font-family: "FontAwesome";
			font-weight: normal;
			text-align: center;
		}
		.close_button {
			float: right;
			text-decoration: none;
			color: black;
			margin-left: 10px;
		}
		.close_button:before {
			content: "";
		}
		.close_button:hover:before {
			content: "";
		}
		.thumbs_up:before {
			content: ""
		}
		.thumbs_down:before {
			content: ""
		}
		/* Table Styles */
		table {
			width: 100%;
			font-size: 12px;
			font-weight: bold;
			border-collapse: collapse;
			border: solid darkgray 1px;
			margin-bottom: 30px;
		}
		thead td {
			background-color: lightgray;
			border: solid darkgray 1px;
		}
		td {
			padding: 2px;
			margin: 0px;
			border-right: solid darkgray 1px;
		}
		td.sortable {
			cursor: pointer;
		}
		tr:nth-child(2n) {
			background-color: lightgray;
		}
		tr.selected {
			background-color: #BBF;
		}
		tr.selected:nth-child(2n) {
			background-color: #AAF;
		}
		tbody td {
			min-width: 25px;
			max-width: 250px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		.like {
			color: #83C328;
		}
		.dislike {
			color: #C32828;
		}
		/* Tag Styles */
		img.character {
			cursor: pointer;
			margin-right: 2px;
			border-radius: 3px;
			height: 16px;
			vertical-align: -3px;
		}
		a.sort_indicator {
			float:right;
		}
		a.category {
			cursor: pointer;
			display: inline-block;
			font-size: 0.7em;
			padding: 2px 2px;
			margin-right: 2px;
			vertical-align: middle;
			color: white;
			background-color: darkgray;
			border: solid 1px rgba(0, 0, 0, 0.2);
			box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.4) inset;
			text-shadow: -1px -1px rgba(0, 0, 0, 0.2);
		}
		a.sex { background-image: linear-gradient(to bottom, #992584 0%, #821F70 100%); }
		a.gore { background-image: linear-gradient(to bottom, #742828 0%, #622222 100%); }
		a.romance { background-image: linear-gradient(to bottom, #7C40BB 0%, #7139AA 100%); }
		a.tragedy { background-image: linear-gradient(to bottom, #EBA42D 0%, #D49528 100%); }
		a.sad { background-image: linear-gradient(to bottom, #E3628D 0%, #CE5980 100%); }
		a.dark { background-image: linear-gradient(to bottom, #9F2424 0%, #902121 100%); }
		a.comedy { background-image: linear-gradient(to bottom, #D4AE00 0%, #BF9D00 100%); }
		a.random { background-image: linear-gradient(to bottom, #4279D8 0%, #3B6EC3 100%); }
		a.crossover { background-image: linear-gradient(to bottom, #4AC1A8 0%, #43AE98 100%); }
		a.adventure { background-image: linear-gradient(to bottom, #48D354 0%, #41BE4C 100%); }
		a.slice_of_life { background-image: linear-gradient(to bottom, #424CD9 0%, #3B45C4 100%); }
		a.alternate_universe { background-image: linear-gradient(to bottom, #8E8E8E 0%, #818181 100%); }
		a.human { background-image: linear-gradient(to bottom, #BE895E 0%, #AB7C55 100%); }
		a.anthro { background-image: linear-gradient(to bottom, #BE6E5E 0%, #AB6355 100%); }
		/* Comment Overlay Styles */
		div.overlay {
			position: fixed;
			top: 0px;
			left: 0px;
			bottom: 0px;
			right: 0px;
			background-color: rgba(0, 0, 0, 0.5);
			padding: 50px;
		}
		div.overlay h2 {
			height: 25px;
			margin: 0px;
			padding: 20px;
			background-color: white;
			border: solid gray 1px;
		}
		div.overlay ul {
			margin: 0px;
		}
		div.overlay li {
			height: 22px;
			overflow-y: hidden;
			position: relative;
			left: -50px;
			top: 19px;
			z-index: 10;
			background-color: #C3C3C3;
			display: inline-block;
			border: solid 1px gray;
			border-bottom: none;
			border-radius: 10px 10px 0px 0px;
			padding-top: 2px;
			padding-left: 5px;
			padding-right: 5px;
			padding-bottom: 0px;
			font-weight: bold;
			font-size: 16px;
			margin-right: 5px;
			cursor: pointer;
		}
		div.overlay li.selected_tab {
			top: 20px;
			height: 23px;
			background-color: lightgray;
			/* we show the text cursor for the active tab only */
			cursor: auto;
		}
		div.overlay li a {
			position: relative;
			top: 2px;
		}
		div.profile_tab {
			border-bottom: solid gray 1px;
			border-right: solid gray 1px;
			border-left: solid gray 1px;
			background-color: lightgray;
			padding: 1em;
			position: absolute;
			top: 67px;
			left: 0px;
			bottom: 0px;
			right: 0px;
			margin: 50px;
		}
		div.story_comments {
			border-bottom: solid gray 1px;
			border-right: solid gray 1px;
			border-left: solid gray 1px;
			background-color: white;
			position: absolute;
			top: 67px;
			left: 0px;
			bottom: 0px;
			right: 0px;
			margin: 50px;
			overflow-y: scroll;
		}
		div.story_comments div.comment {
			border-right: none;
			border-left: none;
			border-top: none;
		}
		div.story_comments div.comment:last-child {
			border-bottom: none;
		}
		/* Statusbar Styles */
		div#statusbar {
			position: fixed;
			bottom: 0px;
			left: 0px;
			right: 0px;
			border: none;
			border-top: 1px solid gray;
			background-color: white;
			padding: 3px;
			font-weight: bold;
			font-size: 12px;
		}
	</style>
	<script type="text/javascript">
		var db;
		var charTable = {};
		//l2 = [{tag: "a", attrs: {title: cat, className: "category " + cat.toLowerCase().replace(/ /g, "_")}, children: [cat.slice(0, 2)]} for(cat of l)]
		var catTable = {
			"Sex": {tag: "a", attrs: {title: "Sex", className: "category sex"}, children: ["Se"]}, 
			"Gore": {tag: "a", attrs: {title: "Gore", className: "category gore"}, children: ["Go"]}, 
			"Romance": {tag: "a", attrs: {title: "Romance", className: "category romance"}, children: ["Ro"]}, 
			"Tragedy": {tag: "a", attrs: {title: "Tragedy", className: "category tragedy"}, children: ["Tr"]}, 
			"Sad": {tag: "a", attrs: {title: "Sad", className: "category sad"}, children: ["Sa"]}, 
			"Dark": {tag: "a", attrs: {title: "Dark", className: "category dark"}, children: ["Da"]}, 
			"Comedy": {tag: "a", attrs: {title: "Comedy", className: "category comedy"}, children: ["Co"]}, 
			"Random": {tag: "a", attrs: {title: "Random", className: "category random"}, children: ["Ra"]}, 
			"Crossover": {tag: "a", attrs: {title: "Crossover", className: "category crossover"}, children: ["Cr"]}, 
			"Adventure": {tag: "a", attrs: {title: "Adventure", className: "category adventure"}, children: ["Ad"]}, 
			"Slice of Life": {tag: "a", attrs: {title: "Slice of Life", className: "category slice_of_life"}, children: ["Sl"]}, 
			"Alternate Universe": {tag: "a", attrs: {title: "Alternate Universe", className: "category alternate_universe"}, children: ["Al"]}, 
			"Human": {tag: "a", attrs: {title: "Human", className: "category human"}, children: ["Hu"]}, 
			"Anthro": {tag: "a", attrs: {title: "Anthro", className: "category anthro"}, children: ["An"]}
		};
		var userAvatarURLs = {};
		var parser = new bbcode();
		parser.setLocalSite("http://fimfiction.net");
		function init() {
			db = new FFDB("fimcomments-db", function() {
				getUserAvatars(function() {
					fetchChars(function() {
						fetchEmotes(init2);
					});
				});
			});
		}
		function init2() {
			writeStoryTable();
			document.addEventListener("click", handleClick);
			document.addEventListener("mousedown", handleSelection);
			window.addEventListener("hashchange", showOverlay);
			// hash may exist when page is loaded, so manually run showOverlay
			showOverlay();
		}
		function getUserAvatars(callback) {
			db.getAll("users", function(items) {
				for(var i in items) {
					userAvatarURLs[items[i].name] = URL.createObjectURL(items[i].avatar);
				}
				callback();
			});
		}
		var lastSort, invertSort;
		var sortIndicator = createTree({tag: "a", attrs: {className: "sort_indicator"}, children: ["\u25B2"]});
		function moveSortIndicator(cat, element, type) {
			if(cat == lastSort) {
				invertSort = !invertSort;
			}else{
				invertSort = false;
			}
			lastSort = cat;
			sortIndicator.firstChild.data = invertSort?"\u25BC":"\u25B2";
			while(sortIndicator.childNodes.length > 1) sortIndicator.removeChild(sortIndicator.lastChild);
			if(type) sortIndicator.appendChild(type);
			element.appendChild(sortIndicator);
		}
		function handleClick(event) {
			if(event.target.classList.contains("sortable")) {
				var cat = event.target.getAttribute("data-sort");
				moveSortIndicator(cat, event.target);
				if(cat == "comment") {
					// this behavior is fairly arbitrary, but it fits what I need
					if(invertSort) {
						cat = "newest_comment";
					}else{
						cat = "oldest_comment";
					}
				}
				switch(cat) {
					case "title":
					case "author":
						sortByAlphabeticMember(cat, invertSort);
						break;
					case "wordcount":
					case "tracking":
					case "read_later":
					case "created":
					case "updated":
					case "my_rating":
					// these are added at runtime
					case "floatRating":
					case "comment_count":
					case "oldest_comment":
					case "newest_comment":
						sortByNumericMember(cat, invertSort);
						break;
					default:
						break;
				}
			}else if(event.target.classList.contains("category") || event.target.classList.contains("character")) {
				var type = event.target.classList.contains("category");
				var col = type?document.querySelector("td#categories"):document.querySelector("td#characters");
				var cat = event.target.title;
				moveSortIndicator(cat, col, event.target.cloneNode(true));
				sortByTag(type?"category":"character", cat, invertSort);
			}
		}
		var selectedRows = [];
		var lastSelected;
		function handleSelection(event) {
			if(event.target.parentNode.tagName == "TR") {
				// table row, perform selection routine
				var row = event.target.parentNode;
				// check that we're not clicking the header
				if(row.parentNode.tagName != "TBODY") return;
				// various behaviours for modifier keys
				if(event.shiftKey) {
					event.preventDefault();
					// make a range selection
					if(!lastSelected) {
						// if no selection has been made yet, we'll just set one
						selectedRows.push(row);
						row.classList.add("selected");
						lastSelected = row;
					}else{
						while(selectedRows.length) {
							selectedRows.pop().classList.remove("selected");
						}
						var trows = row.parentNode.children;
						var selecting = false;
						for(var ri = 0; ri < trows.length; ri++) {
							var trow = trows[ri];
							if(trow == lastSelected) selecting = !selecting;
							if(trow == row) selecting = !selecting;
							if(selecting || trow == lastSelected || trow == row) {
								trow.classList.add("selected");
								selectedRows.push(trow);
							}
						}
					}
				}else if(event.ctrlKey) {
					event.preventDefault();
					// toggle selection on element
					var index = selectedRows.indexOf(row);
					if(index == -1) {
						selectedRows.push(row);
						row.classList.add("selected");
					}else{
						selectedRows.splice(index, 1);
						row.classList.remove("selected");
					}
					lastSelected = row;
				}else{
					// set exclusive selection
					while(selectedRows.length) {
						selectedRows.pop().classList.remove("selected");
					}
					selectedRows.push(row);
					row.classList.add("selected");
					lastSelected = row;
				}
				// afterwards, display the selection stats
				var selectionWords = 0;
				for(var row of selectedRows) {
					selectionWords += row.storyData.wordcount;
				}
				document.getElementById("selection_info").innerHTML = selectedRows.length.toLocaleString() + " stories, " + selectionWords.toLocaleString() + " words";
			}
		}
		function sortTable(table, func) {
			// sorts the contents of the first tbody according to a given sort function
			var c, tc = [];
			var tb = table.tBodies[0];
			// we remove the body before modifying it to prevent re-rendering the table while we are sorting it
			table.removeChild(tb);
			for(c of tb.children) {
				tc.push(c);
			}
			tc.sort(func);
			for(c of tc) {
				// we don't actually need to remove elements to append them
				// this just moves them to the end of the child list
				tb.appendChild(c);
			}
			table.appendChild(tb);
		}
		// document.querySelector("table").appendChild(document.createElement("tbody")); writeStoryTable();
		function sortByNumericMember(member, invert) {
			// sorts the table by a numeric base storyData member
			// works for booleans and dates as well as numbers
			// for RIL, Fav, created, and updated, we must deal with the case of an undefined value
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData[member];
				b = b.storyData[member];
				// sort undefined, NaN and Infinity to the end, regardless of sort order
				if(!isFinite(a)) return 1;
				if(!isFinite(b)) return -1;
				return a - b;
			}:function(b, a) {
				a = a.storyData[member];
				b = b.storyData[member];
				// sort undefined, NaN and Infinity to the end, regardless of sort order
				if(!isFinite(a)) return -1;
				if(!isFinite(b)) return 1;
				return a - b;
			});
		}
		function sortByAlphabeticMember(member, invert) {
			// sorts the table by a alphabetic base storyData member
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData[member].toLowerCase();
				b = b.storyData[member].toLowerCase();
				return a < b ? 1 : a > b ? -1 : 0;
			}:function(b, a) {
				a = a.storyData[member].toLowerCase();
				b = b.storyData[member].toLowerCase();
				return a < b ? 1 : a > b ? -1 : 0;
			});
		}
		function sortByTag(type, tag, invert) {
			// sorts the table by one of the character or category tags
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData.tags[type].indexOf(tag) != -1;
				b = b.storyData.tags[type].indexOf(tag) != -1;
				return a - b;
			}:function(b, a) {
				a = a.storyData.tags[type].indexOf(tag) != -1;
				b = b.storyData.tags[type].indexOf(tag) != -1;
				return a - b;
			});
		}
		function writeStoryTable() {
			// feed all the comments into a fragment so we can add them simultaneously
			var frag = document.createDocumentFragment();
			// get all comments ordered by location
			var groups, groupCount;
			db.getAll("stories", function(items) {
				var rows = document.createDocumentFragment();
				var countUpdatesRequired = 0;
				var countUpdates = [];
				for(var story of items) {
					var cat;
					story.floatRating = story.ratings.up / (story.ratings.up + story.ratings.down); // so we can sort by this
					if(isNaN(story.floatRating)) story.floatRating = 0; // in case there are no ratings
					var percentRating = parseInt(story.floatRating * 100);
					var rowStruct = {tag: "tr", children: [
						{tag: "td", children: [{tag: "a", attrs: {href: "http://fimfiction.net/story/" + story.id}, children: [story.title]}]},
						{tag: "td", children: [{tag: "a", attrs: {href: "http://fimfiction.net/user/" + story.author.replace(/ /g, "+")}, children: [story.author]}]},
						{tag: "td", attrs: {style: "text-align: right;"}, children: [story.wordcount.toLocaleString()]},
						{tag: "td", attrs: {
								style: percentRating == 0?"background-color: rgba(255, 0, 0, 0.3);":"background-image: linear-gradient(to right, rgba(0, 255, 0, 0.3) " + percentRating + "%, rgba(255, 0, 0, 0.3) " + percentRating + "%);text-align: right;"
							}, 
							children: [percentRating + "%"]
						},
						{tag: "td", children: [catTable[cat] for(cat of story.tags.category)]},
						{tag: "td", children: [{tag: "img", attrs: {src: charTable[cat], title: cat, className: "character"}} for(cat of story.tags.character)]},
						{tag: "td", children: story.created?story.created.toDateString().slice(4):""},
						{tag: "td", children: story.updated?story.updated.toDateString().slice(4):""},
						{tag: "td", 
							attrs: {className: "fa" + (story.my_rating > 0?" like":story.my_rating < 0?" dislike":"")}, 
							children: story.my_rating > 0?"\uf164":story.my_rating < 0?"\uf165":""
						},
						{tag: "td", attrs: {className: "fa"}, children: story.tracking?"":""},
						{tag: "td", attrs: {className: "fa"}, children: story.read_later?"":""},
						{tag: "td", attrs: {style: "text-align: right;"}} // this will contain the comment count
					]};
					var row = createTree(rowStruct);
					row.storyData = story;
					if("comment_count" in row.storyData && "oldest_comment" in row.storyData) {
						if(row.storyData.comment_count > 0) {
							var link = document.createElement("a");
							link.appendChild(document.createTextNode(row.storyData.comment_count));
							row.lastChild.appendChild(link);
							link.href = "#story_comments/" + row.storyData.id;
						}else{
							row.lastChild.appendChild(document.createTextNode("0"));
						}
					}
					if(!("comment_count" in row.storyData) || !("oldest_comment" in row.storyData)) {
						// the comment count hasn't been cached yet, so we must determine it
						row.storyData.comment_count = 0; // in case we try to sort by this immediately
						// record that this needs to be updated
						countUpdatesRequired++;
						db.getItemsByIndex("comments", "location", "story/" + story.id, function (row) { return function(items) {
							// cache the value so we don't have to do this again
							var update = {
								id: row.storyData.id, 
								comment_count: items.length, 
								oldest_comment: items.length?items[0].date:NaN, 
								newest_comment: items.length?items[items.length - 1].date:NaN
							};
							countUpdates.push(update);
							if(countUpdatesRequired > 0 && countUpdates.length >= countUpdatesRequired) {
								// updates batched into one transaction for speed
								db.updateItems("stories", countUpdates, function() {
									console.log("Updated " + countUpdatesRequired + " story entries");
								});
							}
							row.storyData.comment_count = update.comment_count;
							row.storyData.oldest_comment = update.oldest_comment;
							row.storyData.newest_comment = update.newest_comment;
							if(row.storyData.comment_count > 0) {
								var link = document.createElement("a");
								link.appendChild(document.createTextNode(row.storyData.comment_count));
								row.lastChild.appendChild(link);
								link.href = "#story_comments/" + row.storyData.id;
							}else{
								row.lastChild.appendChild(document.createTextNode("0"));
							}
						};}(row));
					}
					rows.appendChild(row);
				}
				document.querySelector("tbody").appendChild(rows);
			});
		}
		function closeOverlay() {
			// remove any hash from the url bar
			history.pushState("", document.title, window.location.pathname);
			showOverlay();
		}
		function showOverlay() {
			// remove existing overlays
			if(document.body.lastChild.className == "overlay") {
				document.body.lastChild.remove();
			}
			// see what we need to show
			var h = window.location.hash.split("/");
			if(h[0] == "#story_comments") {
				var storyId = h[1];
				// blah, we have to get both the comments and the story name
				db.getItemsByIndex("comments", "location", "story/" + storyId, function(comments) {
					db.getItem("stories", storyId, function(story) {
						var header = {tag: "div", attrs: {className: "overlay"}, children: [
							{tag: "h2", children: [
								((story && story.title) || storyId) + " (" + comments.length + ")",
								{tag: "a", attrs: {className: "fa close_button", href: "javascript:closeOverlay()"}}
							]},
							{tag: "div", attrs: {className: "story_comments"}}
						]};
						var container = createTree(header);
						for(var comment of comments) {
							container.lastChild.appendChild(createComment(comment, userAvatarURLs[comment.author]));
						}
						document.body.appendChild(container);
					});
				});
			}else if(h[0] == "#sync_interface") {
				// fetch profile data, and create it if neccessary
				var defaultProfileSettings = JSON.stringify([
					{name: "Destination Folder", type: "FilePath", value: ""},
					{name: "Source Folder", type: "FilePath", value: ""},
					{name: "Files to Sync", type: "select", value: "Selected", options: ["Selected", "Tracking", "ReadItLater", "Upvotes", "Downvotes"]},
					{name: "Download Type", type: "select", value: "html", options: ["txt", "html", "epub"]},
					{name: "Delete Duplicates", type: "bool", value: false},
					{name: "Keep Old Versions", type: "bool", value: false}
				]);
				var profiles = JSON.parse(localStorage.getItem("profiles"));
				if(profiles == null) {
					profiles = [{name: "Profile 1", settings: JSON.parse(defaultProfileSettings)}];
					var selectedProfileIndex = 0;
				}else{
					var selectedProfileIndex = parseInt(localStorage.getItem("selectedProfileIndex"));
				}
				// the profile editing functions
				// might move elsewhere to avoid spaghettification
				function saveProfileInfo() {
					//console.log(JSON.stringify(profiles));
					localStorage.setItem("profiles", JSON.stringify(profiles));
					localStorage.setItem("selectedProfileIndex", selectedProfileIndex);
				}
				function bindTabClick(tabProfile) {
					return function(event) {
						if(event.target.classList.contains("selected_tab")) {
							// edit the name of the tab
							var str = event.target.firstChild.data;
							var entry = document.createElement("input");
							entry.value = str;
							event.target.replaceChild(entry, event.target.firstChild);
							// select and focus the edit widget
							entry.selectionStart = 0;
							entry.selectionEnd = entry.value.length;
							// post edit saving
							function saveField(field) {
								tabProfile.name = field.value;
								var parent = field.parentNode;
								parent.replaceChild(document.createTextNode(tabProfile.name), field);
								saveProfileInfo();
							}
							entry.addEventListener("keypress", function(event) {
								if(event.key == "Enter") {
									saveField(event.target);
								}
							}, false);
							entry.addEventListener("blur", function(event) {
								saveField(event.target);
							}, false);
							entry.focus();
						}else if(tabProfile.addTab) {
							// add a new tab
							selectedProfileIndex = profiles.length;
							profiles.push({name: "Profile " + (profiles.length + 1), settings: JSON.parse(defaultProfileSettings)});
							rewriteTabList();
						}else{
							// select the tab
							selectedProfileIndex = event.target.profileIndex;
							rewriteTabList();
						}
					};
				}
				function rewriteTabList() {
					var newTabList, newSettingControls;
					tabList.parentNode.replaceChild(newTabList = createTabList(), tabList);
					tabList = newTabList;
					settingControls.parentNode.replaceChild(newSettingControls = createSettingControls(), settingControls);
					settingControls = newSettingControls;
					saveProfileInfo();
				}
				function deleteProfileTab(event) {
					profiles.splice(event.target.parentNode.profileIndex, 1);
					if(selectedProfileIndex >= profiles.length) {
						selectedProfileIndex = profiles.length - 1;
					}
					rewriteTabList();
					// prevent the tab selection function from being called too
					event.stopPropagation();
				}
				function performSync() {
					// reformat the settings structure so it's easy to use
					var s = profiles[selectedProfileIndex].settings.reduce(function(o, i) {o[i.name.toLowerCase().replace(/ /g, "_")] = i.value; return o}, {});
					// generate file list based on files_to_sync and download_type settings
					var files = [];
					// it might be better to query the database for some of these
					function sanitizeFilname(fn) {
						// TODO: we're going to need to do something about stories that share titles
						// Also, I couldn't find a standard interface for stripping invalid characters from a filename
						// so this is windows-specific, probably incomplete filename sanitization
						return fn.replace(/[\\\/:\*\?"<>|]/g, "_");
					}
					function generateDownloadUrl(id) {
						/* Example URLs
						txt: https://www.fimfiction.net/download_story.php?story=221415
						html: https://www.fimfiction.net/download_story.php?story=221415&html
						epub: https://www.fimfiction.net/download_epub.php?story=221415
						
						AAAARGH download_epub returns a completely different Content-Disposition filename
						formatted in title.toLowerCase().replace(/ /g, "-") style
						*/
						switch(s.download_type) {
							case "txt":
								return "https://www.fimfiction.net/download_story.php?story=" + id;
							case "html":
								return "https://www.fimfiction.net/download_story.php?story=" + id + "&html";
							case "epub":
								return "https://www.fimfiction.net/download_epub.php?story=" + id;
						}
					}
					function syncObjectFromStoryData(sd) {
						return {name: sanitizeFilname(sd.title) + "." + s.download_type, url: generateDownloadUrl(sd.id), modified: sd.updated};
					}
					switch(s.files_to_sync) {
						case "Selected":
							for(var row of selectedRows) {
								files.push(syncObjectFromStoryData(row.storyData));
							}
							break;
						case "Tracking":
							for(var row of document.querySelector("table").tBodies[0].children) {
								var sd = row.storyData;
								if(sd.tracking) {
									files.push(syncObjectFromStoryData(sd));
								}
							}
							break;
						case "ReadItLater":
							for(var row of document.querySelector("table").tBodies[0].children) {
								var sd = row.storyData;
								if(sd.read_later) {
									files.push(syncObjectFromStoryData(sd));
								}
							}
							break;
						case "Upvotes":
							for(var row of document.querySelector("table").tBodies[0].children) {
								var sd = row.storyData;
								if(sd.my_rating > 0) {
									files.push(syncObjectFromStoryData(sd));
								}
							}
							break;
						case "Downvotes":
							for(var row of document.querySelector("table").tBodies[0].children) {
								var sd = row.storyData;
								if(sd.my_rating < 0) {
									files.push(syncObjectFromStoryData(sd));
								}
							}
							break;
						default:
							console.log("Unimplemented sync type");
							return;
							break;
					}
					// replace the settingControls with the status log
					var statusLog = createTree({tag: "div", attrs: {className: "profile_tab", style: "overflow-y: scroll;"}});
					settingControls.parentNode.replaceChild(statusLog, settingControls);
					settingControls = statusLog;
					function log(msg) {
						statusLog.appendChild(createTree({tag: "div", children: [msg]}));
					}
					// set up a listener to receive status messages about the operation
					addEventListener("message", function listener(e) {
						if(e.data.request == "SyncStatusLog") {
							if(e.data.msg == "Sync Complete" || e.data.msg instanceof Error) {
								removeEventListener("message", listener, false);
							}
							log(e.data.msg.toString());
						}
					}, false);
					// send off our result
					log("Checking for updates to " + files.length + " stories");
					postMessage({request: "SyncFolders", files: files, dest: s.destination_folder, source: s.source_folder, deleteFromSource: s.delete_duplicates, keepOld: s.keep_old_versions}, "*");
				}
				function createSettingControls() {
					// we also need to rewrite all the info in the info window
					var struct = [];
					for(var setting of profiles[selectedProfileIndex].settings) {
						switch(setting.type) {
							case "FilePath":
								function changeFilePath(setting) {
									return function(value) {
										document.querySelector("input[title='" + setting.name + "']").value = value;
										setting.value = value;
										saveProfileInfo();
									};
								}
								struct.push({tag: "div", attrs: {style: "padding-bottom: 0.5em"}, children: [
									{tag: "label", attrs: {style: "float: left; margin-top: 1px; width: 10em;"}, children: [setting.name + ":"]},
									{tag: "input", attrs: {style: "float: right; margin-top: -1px;", type: "button", value: "...", onclick: pickFolder(setting.name, changeFilePath(setting))}},
									{tag: "span", attrs: {style:"display:block; overflow:hidden;"}, children: [
										{tag: "input", attrs: {style: "width: 100%;", type: "text", title: setting.name, value: setting.value, placeholder: "...", disabled: "disabled"}}
									]}
								]});
								break;
							case "select":
								function changeSelect(setting) {
									return function(event) {
										setting.value = event.target.value;
										saveProfileInfo();
									};
								}
								struct.push({tag: "div", attrs: {style: "padding-bottom: 0.5em"}, children: [
									{tag: "label", attrs: {style: "float: left; margin-top: 1px; width: 10em;"}, children: [setting.name + ":"]}, 
									{tag: "select", attrs: {onchange: changeSelect(setting)}, children: [for (option of setting.options) option==setting.value?{tag: "option", attrs: {selected: "selected"}, children: [option]}:{tag: "option", children: [option]}]}
								]});
								break;
							case "bool":
								function changeBool(setting) {
									return function(event) {
										setting.value = event.target.checked;
										saveProfileInfo();
									};
								}
								struct.push({tag: "div", attrs: {style: "padding-bottom: 0.5em"}, children: [
									{tag: "label", attrs: {style: "float: left; margin-top: 1px; width: 10em;"}, children: [setting.name + ":"]},
									{tag: "input", attrs: {type: "checkbox", checked: setting.value?"checked":"", onchange: changeBool(setting)}}
								]});
								break;
						}
					}
					return createTree({tag: "div", attrs: {className: "profile_tab"}, children: struct.concat(
						{tag: "input", attrs: {type: "button", value: "Sync", onclick: performSync}}
					)});
				}
				function createTabList() {
					return createTree({tag: "ul", children: [
						for (tab of profiles) {
							tag: "li",
							attrs: {
								className: profiles.indexOf(tab) == selectedProfileIndex?"selected_tab":"",
								profileIndex: profiles.indexOf(tab),
								onclick: bindTabClick(tab)
							},
							children: [
								tab.name
							].concat(profiles.length > 1?{tag: "a", attrs: {className: "fa close_button", onclick: deleteProfileTab, href: "javascript:void(0);"}}:[])
						}
					].concat(
						{
							tag: "li",
							attrs: {
								className: "fa",
								onclick: bindTabClick({addTab: true})
							},
							children: ["\uf067"]
						}
					)});
				}
				// display the interface
				var tabList = createTabList();
				var settingControls = createSettingControls();
				var structure = {tag: "div", attrs: {className: "overlay"}, children: [
					{tag: "h2", children: [
						{tag: "a", attrs: {className: "fa close_button", href: "javascript:closeOverlay()"}},
						{node: tabList}
					]},
					{node: settingControls}
				]};
				document.body.appendChild(createTree(structure));
			}
		}
		function createComment(comment, avatar) {
			// JSONified HTML, because why not
			var cbody = parser.render(comment.data);
			// rewrite the quote links to point to fimfiction
			var qlinks = cbody.querySelectorAll("a.quote_link");
			for(var qlink of qlinks) {
				qlink.href = "http://fimfiction.net/" + comment.location + "/#comment/" + qlink.href.split("#")[1];
			}
			var structure = {tag: "div", attrs: {className: "comment"}, children: [
				{tag: "a", attrs: {className: "jump", name: comment.id}},
				{tag: "div", attrs: {className: "author"}, children: [
					{tag: "a", attrs: {className: "name", href: "http://fimfiction.net/user/" + comment.author.replace(/ /g, "+")}, children: [comment.author]},
					{tag: "img", attrs: {className: "avatar", src: avatar}}
				]},
				{tag: "div", attrs: {className: "data"}, children: [
					{tag: "div", attrs: {className: "comment_arrow"}, children: [
						{tag: "div"}
					]},
					{tag: "div", attrs: {className: "metadata"}, children: [
						{tag: "a", attrs: {href: "http://fimfiction.net/" + comment.location + "/#comment/" + comment.id}, children: ["#" + comment.id]},
						" · Chapter " + comment.chapter + " · " + comment.date.toLocaleString() + " · " + comment.ratings.up,
						{tag: "span", attrs: {className: "fa thumbs_up"}},
						" · " + comment.ratings.down,
						{tag: "span", attrs: {className: "fa thumbs_down"}}
					]},
					{node: cbody, attrs: {className: "body"}}
				]}
			]};
			return createTree(structure);
		}
		function createTree(node) {
			var tag;
			if(node.tag) {
				tag = document.createElement(node.tag);
			}else if(node.node) {
				// this method of adding existing nodes allows us to add extra attrs
				tag = node.node;
			}
			for(var attr in node.attrs) {
				tag[attr] = node.attrs[attr];
			}
			if(node.children) {
				for(var i = 0; i < node.children.length; i++) {
					if(typeof node.children[i] == "string") {
						tag.appendChild(document.createTextNode(node.children[i]));
					}else{
						tag.appendChild(createTree(node.children[i]));
					}
				}
			}
			return tag;
		}
		function makeBBCodeList() {
			// generates a list of stories with comment links from the selection
			// and puts it on the clipboard in a BBCode format
			document.getElementById("copy_list_link").style.display = "none";
			var completion = [0, selectedRows.length];
			document.getElementById("transaction_status").innerHTML = "Generating list: " + completion[0] + "/" + completion[1];
			var storyOutput = "";
			function writeNextStory() {
				var row = selectedRows[completion[0]];
				var story = row.storyData;
				storyOutput += "[hr]" + story.title + " "
				if(story.my_rating == 1) {
					storyOutput += "[color=#83C328]▲[/color]";
				}else if(story.my_rating == -1) {
					storyOutput += "[color=#C32828]▼[/color]";
				}
				storyOutput += "\n\t";
				db.getKeysByIndex("comments", "location", "story/" + story.id, function(keys) {
					for(var key of keys) {
						storyOutput += "[site_url=/story/" + story.id + "/#comment/" + key + "]#" + key + "[/site_url] ";
					}
					storyOutput += "\n";
					completion[0] += 1;
					document.getElementById("transaction_status").innerHTML = "Generating list: " + completion[0] + "/" + completion[1];
					if(completion[0] == completion[1]) {
						// we're done
						document.getElementById("transaction_status").innerHTML = "";
						document.getElementById("copy_list_link").style.display = "inline";
						// pass the data to the extension to place on the clipboard
						postMessage({request: "CopyString", string: storyOutput}, "*");
					}else{
						writeNextStory();
					}
				});
			}
			writeNextStory();
		}
		function pickFolder(title, callback) {
			return function() {
				function picked(e) {
					if(e.data.request == "PickedFolder") {
						removeEventListener("message", picked, false);
						callback(e.data.folder);
					}
				}
				addEventListener("message", picked, false);
				postMessage({request: "PickFolder", title: title}, "*");
			};
		}
		function pickFile(title, saveFile, callback, fileType) {
			return function() {
				function picked(e) {
					if(e.data.request == "PickedFile") {
						removeEventListener("message", picked, false);
						callback(e.data.filePath);
					}
				}
				addEventListener("message", picked, false);
				postMessage({request: "PickFile", title: title, saveFile: saveFile, fileType: fileType}, "*");
			};
		}
		function readFile(filePath, callback) {
			return function() {
				function readComplete(e) {
					if(e.data.request == "FileRead") {
						removeEventListener("message", readComplete, false);
						callback(e.data.data);
					}
				}
				addEventListener("message", readComplete, false);
				postMessage({request: "ReadFile", name: filePath}, "*");
			};
		}
		function saveBackup() {
			pickFile("Save Backup As", 1, function(filePath) {
				db.getAll("comments", function(comments) {
					db.getAll("stories", function(stories) {
						db.getAll("users", function(users) {
							// fileReader is asynchronous, so we need to pre-transform our Blobs into data uris
							var usersLoaded = 0;
							for(var user of users) {
								var reader = new FileReader();
								reader.onload = function(user, reader) { return function() { userLoaded(user, reader); }; }(user, reader);
								reader.readAsDataURL(user.avatar);
							}
							function userLoaded(user, reader) {
								user.avatar = reader.result;
								usersLoaded++;
								if(usersLoaded == users.length) {
									postMessage({
										request: "WriteFile",
										name: filePath,
										data: JSON.stringify({
											comments: comments,
											stories: stories,
											users: users
										})
									}, "*");
								}
							}
						});
					});
				});
			}, {title: "JSON File", filter: "*.json"})();
		}
		function dateAndBlobReviver(key, value) {
			if(["created", "updated", "date", "oldest_comment", "newest_comment"].indexOf(key) > -1 && typeof value === "string") {
				// revive the date
				return new Date(value);
			}else if(key == "avatar") {
				// revive the avatar blob
				// we stored it as a data uri
				var duri = value.split(",");
				var type = duri[0].split(":")[1].split(";")[0];
				var byteString = atob(duri[1]);
				var arrayBuffer = new ArrayBuffer(byteString.length);
				var intArray = new Uint8Array(arrayBuffer);
				for(var i = 0; i < byteString.length; i++) intArray[i] = byteString.charCodeAt(i);
				return new Blob([intArray], {type: type});
			}
			return value;
		}
		function loadBackup() {
			pickFile("Load Backup", 0, function(filePath) {
				readFile(filePath, function(data) {
					var count = 0;
					data = JSON.parse(data, dateAndBlobReviver);
					db.putItems("comments", data["comments"], cb);
					db.putItems("stories", data["stories"], cb);
					db.putItems("users", data["users"], cb);
					function cb() {
						count++;
						if(count == 3) {
							console.log("load completed");
						}
					}
				})();
			}, {title: "JSON File", filter: "*.json"})();
		}
	</script>
</head>
<body onload="init()">
	<table>
		<thead>
			<tr>
				<td class="sortable" data-sort="title">Title</td>
				<td class="sortable" data-sort="author">Author</td>
				<td class="sortable" data-sort="wordcount">Words</td>
				<td class="sortable" data-sort="floatRating">Ratings</td>
				<td id="categories">Categories</td>
				<td id="characters">Characters</td>
				<td class="sortable" data-sort="created">Created</td>
				<td class="sortable" data-sort="updated">Updated</td>
				<td class="fa sortable" data-sort="my_rating"></td>
				<td class="fa sortable" data-sort="tracking"></td>
				<td class="fa sortable" data-sort="read_later"></td>
				<td class="fa sortable" data-sort="comment"></td>
			</tr>
		</thead>
		<tbody>
		</tbody>
	</table>
	<div id="statusbar">
		Selected: <span id="selection_info"></span>
		<span style="float:right;" id="transaction_status"></span>
		<a style="float:right;" id="copy_list_link" href="javascript:makeBBCodeList()">Copy Selected Stories</a>
		<a style="float:right;margin-right:1em;" href="#sync_interface">Sync Stories</a>
		<a style="float:right;margin-right:1em;" href="javascript:saveBackup()">Save Backup</a>
		<a style="float:right;margin-right:1em;" href="javascript:loadBackup()">Load Backup</a>
	</div>
</body>
</html>

