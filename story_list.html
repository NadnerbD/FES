<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<link rel="stylesheet" type="text/css" href="comments.css" />
	<script type="text/javascript">
		// fetch emoticon list
		function fetchEmotes(callback) {
			var request = new XMLHttpRequest();
			request.onload = function() {
				if(request.status == 200) {
					var emoteObject = {};
					var emoteList = JSON.parse(request.response);
					for(var item of emoteList) {
						emoteObject[item[0]] = "emotes/" + item[0] + ".png";
					}
					parser.registerEmotes(emoteObject);
					callback();
				}
			};
			request.overrideMimeType("application/json");
			request.open("GET", "emotes/emoticons.json", true);
			request.send(null);
		}
	</script>
	<script type="text/javascript">
		// fetch character list
		function fetchChars(callback) {
			var request = new XMLHttpRequest();
			request.onload = function() {
				if(request.status == 200) {
					var charList = JSON.parse(request.response);
					for(var item of charList) {
						charTable[item[0]] = "characters/" + item[1].split("/").pop();
					}
					callback();
				}
			};
			request.overrideMimeType("application/json");
			request.open("GET", "characters/characters.json", true);
			request.send(null);
		}
	</script>
	<script type="text/javascript" src="idb-wrapper.js"></script>
	<script type="text/javascript" src="bbcode.js"></script>
	<link rel="stylesheet" type="text/css" href="bbcode.css" />
	<style type="text/css">
		table {
			width: 100%;
			font-size: 12px;
			font-weight: bold;
			border-collapse: collapse;
			border: solid darkgray 1px;
		}
		thead td {
			background-color: lightgray;
			border: solid darkgray 1px;
		}
		td {
			padding: 2px;
			margin: 0px;
			border-right: solid darkgray 1px;
		}
		td.sortable {
			cursor: pointer;
		}
		tr:nth-child(2n) {
			background-color: lightgray;
		}
		tbody td:nth-child(3) {
			text-align: right;
		}
		tbody td:nth-child(4) {
			text-align: right;
		}
		tbody td:nth-child(9) {
			text-align: center;
		}
		tbody td:nth-child(10) {
			text-align: center;
		}
		img.character {
			cursor: pointer;
			margin-right: 2px;
			border-radius: 3px;
			height: 16px;
			vertical-align: -3px;
		}
		a.sort_indicator {
			float:right;
		}
		a.category {
			cursor: pointer;
			display: inline-block;
			font-size: 0.7em;
			padding: 2px 2px;
			margin-right: 2px;
			vertical-align: middle;
			color: white;
			background-color: darkgray;
			border: solid 1px rgba(0, 0, 0, 0.2);
			box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.4) inset;
			text-shadow: -1px -1px rgba(0, 0, 0, 0.2);
		}
		a.romance { background-image: linear-gradient(to bottom, #7C40BB 0%, #7139AA 100%); }
		a.tragedy { background-image: linear-gradient(to bottom, #EBA42D 0%, #D49528 100%); }
		a.sad { background-image: linear-gradient(to bottom, #E3628D 0%, #CE5980 100%); }
		a.dark { background-image: linear-gradient(to bottom, #9F2424 0%, #902121 100%); }
		a.comedy { background-image: linear-gradient(to bottom, #D4AE00 0%, #BF9D00 100%); }
		a.random { background-image: linear-gradient(to bottom, #4279D8 0%, #3B6EC3 100%); }
		a.crossover { background-image: linear-gradient(to bottom, #4AC1A8 0%, #43AE98 100%); }
		a.adventure { background-image: linear-gradient(to bottom, #48D354 0%, #41BE4C 100%); }
		a.slice_of_life { background-image: linear-gradient(to bottom, #424CD9 0%, #3B45C4 100%); }
		a.alternate_universe { background-image: linear-gradient(to bottom, #8E8E8E 0%, #818181 100%); }
		a.human { background-image: linear-gradient(to bottom, #BE895E 0%, #AB7C55 100%); }
		a.anthro { background-image: linear-gradient(to bottom, #BE6E5E 0%, #AB6355 100%); }
	</style>
	<script type="text/javascript">
		var db;
		var charTable = {};
		//l2 = [{tag: "a", attrs: {title: cat, className: "category " + cat.toLowerCase().replace(/ /g, "_")}, children: [cat.slice(0, 2)]} for(cat of l)]
		var catTable = {
			"Romance": {tag: "a", attrs: {title: "Romance", className: "category romance"}, children: ["Ro"]}, 
			"Tragedy": {tag: "a", attrs: {title: "Tragedy", className: "category tragedy"}, children: ["Tr"]}, 
			"Sad": {tag: "a", attrs: {title: "Sad", className: "category sad"}, children: ["Sa"]}, 
			"Dark": {tag: "a", attrs: {title: "Dark", className: "category dark"}, children: ["Da"]}, 
			"Comedy": {tag: "a", attrs: {title: "Comedy", className: "category comedy"}, children: ["Co"]}, 
			"Random": {tag: "a", attrs: {title: "Random", className: "category random"}, children: ["Ra"]}, 
			"Crossover": {tag: "a", attrs: {title: "Crossover", className: "category crossover"}, children: ["Cr"]}, 
			"Adventure": {tag: "a", attrs: {title: "Adventure", className: "category adventure"}, children: ["Ad"]}, 
			"Slice of Life": {tag: "a", attrs: {title: "Slice of Life", className: "category slice_of_life"}, children: ["Sl"]}, 
			"Alternate Universe": {tag: "a", attrs: {title: "Alternate Universe", className: "category alternate_universe"}, children: ["Al"]}, 
			"Human": {tag: "a", attrs: {title: "Human", className: "category human"}, children: ["Hu"]}, 
			"Anthro": {tag: "a", attrs: {title: "Anthro", className: "category anthro"}, children: ["An"]}
		};
		var userAvatarURLs = {};
		var parser = new bbcode();
		function init() {
			db = new FFDB("fimcomments-db", function() {
				getUserAvatars(function() {
					fetchChars(function() {
						fetchEmotes(init2);
					});
				});
			});
		}
		function init2() {
			writeStoryTable();
			document.addEventListener("click", handleClick);
			window.onhashchange = highlightSelected;
			highlightSelected();
		}
		function getUserAvatars(callback) {
			db.getAll("users", function(items) {
				for(var i in items) {
					userAvatarURLs[items[i].name] = URL.createObjectURL(items[i].avatar);
				}
				callback();
			});
		}
		var lastSort, invertSort;
		var sortIndicator = createTree({tag: "a", attrs: {className: "sort_indicator"}, children: ["\u25B2"]});
		function moveSortIndicator(cat, element, type) {
			if(cat == lastSort) {
				invertSort = !invertSort;
			}else{
				invertSort = false;
			}
			lastSort = cat;
			sortIndicator.firstChild.data = invertSort?"\u25BC":"\u25B2";
			while(sortIndicator.childNodes.length > 1) sortIndicator.removeChild(sortIndicator.lastChild);
			if(type) sortIndicator.appendChild(type);
			element.appendChild(sortIndicator);
		}
		function handleClick(event) {
			// the most hilarious hack I ever did, literally copies elements from the page into the space where the quote goes
			if(event.target.classList.contains("quote_link")) {
				if(event.target.nextSibling.nodeName == "DIV") {
					event.target.parentNode.removeChild(event.target.nextSibling);
				}else{
					var elem = document.getElementsByName(event.target.hash.substring(1));
					if(elem.length) {
						var quote_container = document.createElement("div");
						quote_container.appendChild(elem[0].parentNode.cloneNode(true));
						event.target.parentNode.insertBefore(quote_container, event.target.nextSibling);
					}
				}
				event.preventDefault();
			}else if(event.target.classList.contains("sortable")) {
				var cat = event.target.getAttribute("data-sort");
				moveSortIndicator(cat, event.target);
				switch(cat) {
					case "title":
					case "author":
						sortByAlphabeticMember(cat, invertSort);
						break;
					case "wordcount":
					case "tracking":
					case "read_later":
					case "created":
					case "updated":
					// these last two are added at runtime
					case "floatRating":
					case "commentCount":
						sortByNumericMember(cat, invertSort);
						break;
					default:
						break;
				}
			}else if(event.target.classList.contains("category") || event.target.classList.contains("character")) {
				var type = event.target.classList.contains("category");
				var col = type?document.querySelector("td#categories"):document.querySelector("td#characters");
				var cat = event.target.title;
				moveSortIndicator(cat, col, event.target.cloneNode(true));
				sortByTag(type?"category":"character", cat, invertSort);
			}
		}
		function highlightSelected() {
			var elem = document.getElementsByClassName("selected");
			for(var i = 0; i < elem.length; i++) {
				elem[i].classList.remove("selected");
			}
			var jump = document.getElementsByName(window.location.hash.substring(1));
			for(var i = 0; i < jump.length; i++) {
				jump[i].parentNode.classList.add("selected");
			}
		}
		function sortTable(table, func) {
			// sorts the contents of the first tbody according to a given sort function
			var c, tc = [];
			var tb = table.tBodies[0];
			// we remove the body before modifying it to prevent re-rendering the table while we are sorting it
			table.removeChild(tb);
			for(c of tb.children) {
				tc.push(c);
			}
			tc.sort(func);
			for(c of tc) {
				// we don't actually need to remove elements to append them
				// this just moves them to the end of the child list
				tb.appendChild(c);
			}
			table.appendChild(tb);
		}
		// document.querySelector("table").appendChild(document.createElement("tbody")); writeStoryTable();
		function sortByNumericMember(member, invert) {
			// sorts the table by a numeric base storyData member
			// works for booleans and dates as well as numbers
			// for RIL, Fav, created, and updated, we must deal with the case of an undefined value
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData[member];
				b = b.storyData[member];
				if(a == undefined) a = 0;
				if(b == undefined) b = 0;
				return a - b;
			}:function(b, a) {
				a = a.storyData[member];
				b = b.storyData[member];
				if(a == undefined) a = 0;
				if(b == undefined) b = 0;
				return a - b;
			});
		}
		function sortByAlphabeticMember(member, invert) {
			// sorts the table by a alphabetic base storyData member
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData[member].toLowerCase();
				b = b.storyData[member].toLowerCase();
				return a < b ? 1 : a > b ? -1 : 0;
			}:function(b, a) {
				a = a.storyData[member].toLowerCase();
				b = b.storyData[member].toLowerCase();
				return a < b ? 1 : a > b ? -1 : 0;
			});
		}
		function sortByTag(type, tag, invert) {
			// sorts the table by one of the character or category tags
			sortTable(document.querySelector("table"), invert?function(a, b) {
				a = a.storyData.tags[type].indexOf(tag) != -1;
				b = b.storyData.tags[type].indexOf(tag) != -1;
				return a - b;
			}:function(b, a) {
				a = a.storyData.tags[type].indexOf(tag) != -1;
				b = b.storyData.tags[type].indexOf(tag) != -1;
				return a - b;
			});
		}
		function writeStoryTable() {
			// feed all the comments into a fragment so we can add them simultaneously
			var frag = document.createDocumentFragment();
			// get all comments ordered by location
			var groups, groupCount;
			db.getAll("stories", function(items) {
				var rows = document.createDocumentFragment();
				for(var story of items) {
					var cat;
					story.floatRating = story.ratings.up / (story.ratings.up + story.ratings.down); // so we can sort by this
					var percentRating = parseInt(story.floatRating * 100);
					var rowStruct = {tag: "tr", children: [
						{tag: "td", children: [{tag: "a", attrs: {href: "http://fimfiction.net/story/" + story.id}, children: [story.title]}]},
						{tag: "td", children: [{tag: "a", attrs: {href: "http://fimfiction.net/user/" + story.author.replace(/ /g, "+")}, children: [story.author]}]},
						{tag: "td", children: [story.wordcount.toLocaleString()]},
						{tag: "td", attrs: {
								style: "background-image: linear-gradient(to right, rgba(0, 255, 0, 0.3) " + percentRating + "%, rgba(255, 0, 0, 0.3) " + percentRating + "%);"
							}, 
							children: [percentRating + "%"]
						},
						{tag: "td", children: [catTable[cat] for(cat of story.tags.category)]},
						{tag: "td", children: [{tag: "img", attrs: {src: charTable[cat], title: cat, className: "character"}} for(cat of story.tags.character)]},
						{tag: "td", children: story.created?story.created.toDateString().slice(4):""},
						{tag: "td", children: story.updated?story.updated.toDateString().slice(4):""},
						{tag: "td", children: story.tracking?"Y":""},
						{tag: "td", children: story.read_later?"Y":""},
						{tag: "td"} // this will contain the comment count
					]};
					var row = createTree(rowStruct);
					row.storyData = story;
					rows.appendChild(row);
					// we should really store the comment count in the story table, because this is slow as shit
					row.storyData.commentCount = 0; // in case we try to sort by this immediately
					db.getKeysByIndex("comments", "location", "story/" + story.id, function (row) { return function(keys) {
						row.lastChild.appendChild(document.createTextNode(keys.length));
						row.storyData.commentCount = keys.length;
					};}(row));
				}
				document.querySelector("tbody").appendChild(rows);
			});
		}
		function createComment(comment, avatar) {
			// JSONified HTML, because why not
			var structure = {tag: "div", attrs: {className: "comment"}, children: [
				{tag: "a", attrs: {className: "jump", name: comment.id}},
				{tag: "div", attrs: {className: "author"}, children: [
					{tag: "a", attrs: {className: "name", href: "/user/" + comment.author.replace(/ /g, "+")}, children: [comment.author]},
					{tag: "img", attrs: {className: "avatar", src: avatar}}
				]},
				{tag: "div", attrs: {className: "data"}, children: [
					{tag: "div", attrs: {className: "comment_arrow"}, children: [
						{tag: "div"}
					]},
					{tag: "div", attrs: {className: "metadata"}, children: [
						{tag: "a", attrs: {href: "#comment/" + comment.id}, children: ["#" + comment.id]},
						"  Chapter " + comment.chapter + "  " + comment.date.toLocaleString() + "  " + comment.ratings.up + "+  " + comment.ratings.down + "-"
					]},
					{node: parser.render(comment.data), attrs: {className: "body"}}
				]}
			]};
			return createTree(structure);
		}
		function createTree(node) {
			var tag;
			if(node.tag) {
				tag = document.createElement(node.tag);
			}else if(node.node) {
				// this method of adding existing nodes allows us to add extra attrs
				tag = node.node;
			}
			for(var attr in node.attrs) {
				tag[attr] = node.attrs[attr];
			}
			if(node.children) {
				for(var i = 0; i < node.children.length; i++) {
					if(typeof node.children[i] == "string") {
						tag.appendChild(document.createTextNode(node.children[i]));
					}else{
						tag.appendChild(createTree(node.children[i]));
					}
				}
			}
			return tag;
		}
	</script>
</head>
<body onload="init()">
	<table>
		<thead>
			<tr>
				<td class="sortable" data-sort="title">Title</td>
				<td class="sortable" data-sort="author">Author</td>
				<td class="sortable" data-sort="wordcount">Words</td>
				<td class="sortable" data-sort="floatRating">Ratings</td>
				<td id="categories">Categories</td>
				<td id="characters">Characters</td>
				<td class="sortable" data-sort="created">Created</td>
				<td class="sortable" data-sort="updated">Updated</td>
				<td class="sortable" data-sort="tracking">Fav</td>
				<td class="sortable" data-sort="read_later">RIL</td>
				<td class="sortable" data-sort="commentCount">C</td>
			</tr>
		</thead>
		<tbody>
		</tbody>
	</table>
</body>
</html>

